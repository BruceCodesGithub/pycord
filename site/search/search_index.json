{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to Pycord \u00b6 Pycord is an API wrapper for the Discord API, which allows you to make Discord Bots. This is an unofficial guide to this Python Wrapper. Using this module, you can easily create Discord Bots with Python. Pycord Guide is a user-friendly guide to help you understand and use the features in Pycord. This guide offers detailed explanations along with examples. Pages \u00b6 Here are a few pages to help you get started: Installing Pycord Creating your first bot Links \u00b6 Discord Server Documentation Github Repo PyPi","title":"Home"},{"location":"#welcome-to-pycord","text":"Pycord is an API wrapper for the Discord API, which allows you to make Discord Bots. This is an unofficial guide to this Python Wrapper. Using this module, you can easily create Discord Bots with Python. Pycord Guide is a user-friendly guide to help you understand and use the features in Pycord. This guide offers detailed explanations along with examples.","title":"Welcome to Pycord"},{"location":"#pages","text":"Here are a few pages to help you get started: Installing Pycord Creating your first bot","title":"Pages"},{"location":"#links","text":"Discord Server Documentation Github Repo PyPi","title":"Links"},{"location":"installation/","text":"Installation \u00b6 This page will show you how you can install Pycord to your device. Fresh Start \u00b6 Linux/macOS: 1 python3 -m pip install -U py-cord Windows: 1 py -3 -m pip install -U py-cord Warning Remember that you need to install py-cord , not pycord . If you need voice support for your bot, for example, playing music, you need to install the Voice Build. Linux/macOS: 1 python3 -m pip install -U \"py-cord[voice]\" Windows: 1 py -3 -m pip install -U py-cord [ voice ] Migrating \u00b6 In case you are migrating from another module, say, discord.py , 1 python -m pip uninstall discord.py -y Next, install py-cord . 1 python -m pip install py-cord Other Builds \u00b6 Alpha \u00b6 Warning The Alpha build can be unstable Tip The Alpha build contains buttons, dropdowns, slash commands, context menu commands, and more features. You may install Pycord Alpha by using: 1 python -m pip install -U git+https://github.com/Pycord-Development/pycord Note If you want to install this, you need GIT. Click here to find out how you can install Git Software. Voice \u00b6 If you need voice support for your bot, for example, playing music, you need to install the Voice Build. Linux/macOS: 1 python3 -m pip install -U \"py-cord[voice]\" Windows: 1 py -3 -m pip install -U py-cord [ voice ] Repl.it \u00b6 Danger Repl.it is not a good IDE. Its online, its free, but you should definitely not use it to host your bot, its not made for that purpose. Your bot will get slower as it gets bigger, and certain files might be deleted. Create a file and name it .replit . Just .replit , with the dot/period at the start. Next, you need to insert the following into the file. 1 2 3 4 5 6 7 8 language=\"python3\" run = \"\"\" pip install py-cord python main.py \"\"\" [packager] ignoredPackages=[\"discord.py\", \"discord\"] Note You may need to change a few things according to your needs, for example, the filename or the installation command ( pip install py-cord ). Also, you do not need to install py-cord everytime Repl.it installs other libraries automatically for you, so its a problem. However, there is a fix to it too. When you run the program (line 3 does so), it keeps reinstalling py-cord , so you may remove it. However, if you are installing alpha, you need it, since repl.it keep rerunning the program after sometime, and installs py-cord stable instead of py-cord alpha if you don't specify it.","title":"Installation"},{"location":"installation/#installation","text":"This page will show you how you can install Pycord to your device.","title":" Installation"},{"location":"installation/#fresh-start","text":"Linux/macOS: 1 python3 -m pip install -U py-cord Windows: 1 py -3 -m pip install -U py-cord Warning Remember that you need to install py-cord , not pycord . If you need voice support for your bot, for example, playing music, you need to install the Voice Build. Linux/macOS: 1 python3 -m pip install -U \"py-cord[voice]\" Windows: 1 py -3 -m pip install -U py-cord [ voice ]","title":"Fresh Start"},{"location":"installation/#migrating","text":"In case you are migrating from another module, say, discord.py , 1 python -m pip uninstall discord.py -y Next, install py-cord . 1 python -m pip install py-cord","title":"Migrating"},{"location":"installation/#other-builds","text":"","title":"Other Builds"},{"location":"installation/#alpha","text":"Warning The Alpha build can be unstable Tip The Alpha build contains buttons, dropdowns, slash commands, context menu commands, and more features. You may install Pycord Alpha by using: 1 python -m pip install -U git+https://github.com/Pycord-Development/pycord Note If you want to install this, you need GIT. Click here to find out how you can install Git Software.","title":"Alpha"},{"location":"installation/#voice","text":"If you need voice support for your bot, for example, playing music, you need to install the Voice Build. Linux/macOS: 1 python3 -m pip install -U \"py-cord[voice]\" Windows: 1 py -3 -m pip install -U py-cord [ voice ]","title":"Voice"},{"location":"installation/#replit","text":"Danger Repl.it is not a good IDE. Its online, its free, but you should definitely not use it to host your bot, its not made for that purpose. Your bot will get slower as it gets bigger, and certain files might be deleted. Create a file and name it .replit . Just .replit , with the dot/period at the start. Next, you need to insert the following into the file. 1 2 3 4 5 6 7 8 language=\"python3\" run = \"\"\" pip install py-cord python main.py \"\"\" [packager] ignoredPackages=[\"discord.py\", \"discord\"] Note You may need to change a few things according to your needs, for example, the filename or the installation command ( pip install py-cord ). Also, you do not need to install py-cord everytime Repl.it installs other libraries automatically for you, so its a problem. However, there is a fix to it too. When you run the program (line 3 does so), it keeps reinstalling py-cord , so you may remove it. However, if you are installing alpha, you need it, since repl.it keep rerunning the program after sometime, and installs py-cord stable instead of py-cord alpha if you don't specify it.","title":"Repl.it"},{"location":"Getting%20Started/coding-your-first-bot/","text":"Creating your first bot \u00b6 Creating the bot \u00b6 Just like how you needed to sign up to Discord to get started, we need to get your bot signed up too. To do this, Go to the Discord Developer Portal and click on New Application . Give your bot a name, and click Create . Now, you should see a page like this. Click on Bot tab on the left side of the screen. Click on Add bot . You can give it a name, change the Avatar, etc. Inviting the bot \u00b6 Now, lets get the bot added to some servers. Go to the OAuth2 tab in the left pane, and select bot and applications.commands as the scope. The applications.command s scope allows the bot to use Slash Commands, which you may want to have. Next, we choose what permissions the bot will have. You can select them. For now, lets give your bot the Administrator permission, meaning the bot will have all the permissions. Once you select the permissions, click on copy to get the bot invite link. You can use this link to invite the bot. Tokens \u00b6 Now that we have an account for our bot, we need to login. In order to login, we need the bot's password. All users and bots have a \"token\". You may think of a token as a unique password, since this is what we use to log into the bot and connect it to Discord. Tokens are \"snowflakes\". Not actual snowflakes, though. Just like how no two snowflakes in real life have the same pattern, a snowflake in computers is a unique thing - no two bots have the same token - so a token is a snowflake. An ID is a snowflake. Now, lets get our bot's token. To do this, Go back to the Bot tab. Click on the Copy button in the \"Token\" section. Now, you have your bot's token copied to your clipboard. Danger Never leak your bot's token, and never share it with anyone. Even if you get any DMs and someone tells you to do so, maybe claiming to be Discord Staff, do not do so. They are probably lying and are scamming you. Anyone with your token will be able to access your bot fully. They will be able to do anything they want with your bot. Never push it to GitHub, or send it with the code. One way to prevent your token from getting leaked is to store it in .env files. Storing the token in an ENV file \u00b6 Storing your bot Token in an ENV File will increase its security, and prevent it from getting leaked. Create a file with the name .env . Just .env , with the dot/period at the start. Define the token in the file, like, 1 TOKEN = [PASTE YOUR TOKEN HERE] for example, 1 TOKEN = NzkyNzE1NDU0MTk2MDg4ODQy.X-hvzA.Ovy4MCQywSkoMRRclStW4xAYK7I Coding the Basics \u00b6 Make sure to install 1 pip install python-dotenv 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 import discord # make sure you install py-cord - read the Installation Page from discord.ext import commands # will be discussed later import os # default module from dotenv import load_dotenv # pip install python-dotenv load_dotenv () # we load all the variables from the env file bot = commands . Bot ( command_prefix = '!' , case_insensitive = True ) @bot . event async def on_ready (): print ( f \" { bot . user } is ready and online!\" ) @bot . command () async def hello ( ctx ): await ctx . send ( \"Hey!\" ) bot . run ( os . getenv ( 'TOKEN' )) import discord In this line, we import the py-cord module. from discord.ext import commands Frankly speaking, the Discord API doesn't have custom commands as you'd expect. It has events, interactions, and more. Hence, many people use the on_message event, which is triggered every time someone sends a message. To make commands, you need to use an extension called commands. Its installed with the library, so no worries! bot = commands.Bot(command_prefix='!', case_insensitive=True) We create an instance of Bot. This connects us to Discord. @bot.event The @bot.event() decorator is used to register an event. This is an asynchronous library, so things are done with callbacks. A callback is a function that is called when something else happens. In this code, the on_ready() event is called when the bot is ready to start being used. We use the @bot.command() decorator to register a command. The callback also becomes the name of the command. In the next lines, we send \"Hey!\" to the user. bot.run(os.getenv('TOKEN')) We get our token from the .env file, and login to Discord Run the bot, and you will have your first bot! Making more commands \u00b6 Ping \u00b6 \"Ping\" or \"Latency\" of the bot is the time it takes to respond to your commands. The less the ping, the better! Ping is calculated in milli seconds, and here's how you can create a cool ping command. 1 2 3 @bot . command ( name = \"ping\" ) async def ping ( ctx ): await ctx . send ( f \"Pong! My latency is: { round ( bot . latency * 1000 ) } ms\" ) A latency of about 300ms is common if you are running the bot from your PC. You may get a better ping by hosting the bot. The top bots pay for the best servers and get a ping of about 10-30ms. Thats 0.04 seconds! Embeds \u00b6 Embeds can make your bot's messages look a lot cooler. It also has other purposes, like fending off imposers - for example, people used to impersonate Dank Memer and trick users into giving them their items. Seeing this, the developers decided to use embeds - since embeds can only be sent by bots and webhooks, no users could impersonate any longer. So, its clear that embeds are pretty nice. Adding them is simple enough too! 1 2 3 4 @bot . command () async def embed ( ctx ): embed = discord . Embed ( title = \"How to make embeds with Py-cord\" , description = \"This tutorial will show you how to make embeds in py-cord. Simple enough, so lets get started!\" , color = discord . Color . from_rbg ( 255 , 255 , 255 )) await ctx . send ( embed = embed ) Fields 1 2 3 4 5 6 7 8 9 @bot . command () async def embed ( ctx ): embed = discord . Embed ( title = \"How to make embeds with Py-cord\" , description = \"This tutorial will show you how to make embeds in py-cord. Simple enough, so lets get started!\" , color = discord . Color . from_rbg ( 255 , 255 , 255 )) embed . add_field ( name = \"With Inline\" , value = \"This is what I would look like with inline\" , inline = True ) embed . add_field ( name = \"With Inline\" , value = \"This is what I would look like with inline\" , inline = True ) embed . add_field ( name = \"With Inline\" , value = \"This is what I would look like with inline\" , inline = True ) embed . add_field ( name = \"Without Inline\" , value = \"This is what I would look like without inline\" , inline = False ) embed . add_field ( name = \"Without Inline\" , value = \"This is what I would look like without inline\" , inline = False ) await ctx . send ( embed = embed ) Headers and Footers 1 2 3 4 5 6 7 8 9 10 11 12 13 14 @bot . command () async def embed ( ctx ): embed = discord . Embed ( title = \"How to make embeds with Py-cord\" , description = \"This tutorial will show you how to make embeds in py-cord. Simple enough, so lets get started!\" , color = discord . Color . from_rbg ( 255 , 255 , 255 ), url = \"...\" ) embed . add_field ( name = \"With Inline\" , value = \"This is what I would look like with inline\" , inline = True ) embed . add_field ( name = \"With Inline\" , value = \"This is what I would look like with inline\" , inline = True ) embed . add_field ( name = \"With Inline\" , value = \"This is what I would look like with inline\" , inline = True ) embed . add_field ( name = \"Without Inline\" , value = \"This is what I would look like without inline\" , inline = False ) embed . add_field ( name = \"Without Inline\" , value = \"This is what I would look like without inline\" , inline = False ) embed . set_footer ( text = \"...\" , icon_url = \"...\" ) embed . set_author ( name = \"Pycord Guide\" , icon_url = '...' , url = \"...\" ) await ctx . send ( embed = embed ) embed . set_footer ( ... , icon_url = ctx . author . avatar_url ) User Input \u00b6 You may want to make commands that require the user to say something, for example, Guess the Number commands. Let's see how you can allow the user to be able to send their own input to the bot. Args \u00b6 In this kind of input, the user will be able to provide the input with the command itself, for example, !gtn 5 . 1 2 3 4 5 6 7 8 9 import random @bot . command () async def gtn ( ctx , guess : int ): number = random . randint ( 1 , 10 ) if guess == number : await ctx . send ( \"You guessed it!) else : await ctx . send ( \"Nope! Better luck next time :)\" ) Code Explanation async def gtn(ctx, guess:int): We set guess as a number parameter. However, if the user enters a value as !gtn 5 5 , it will only take 5 as the input, splitting at spaces. To take the rest of the text as input too, you may use async def gtn(ctx, *, guess:int): instead. This is useful when the args is a string, for example, a feedback command. number = random.randint(1, 10) Using the random module, we generate a random number between 1 to 10. 6 7 8 9 if guess == number : await ctx . send ( \"You guessed it!) else : await ctx . send ( \"Nope! Better luck next time :)\" ) We check if the user's guess was the same as the number that was generated, and inform them if they were right or wrong. Wait for \u00b6 We may want to provide multiple chances to the user, and in this case, args and parameters will not be useful. Instead, we will need to use wait_for . 1 2 3 4 5 6 7 8 9 10 11 import random @bot . command () async def gtn ( ctx ): await ctx . send ( \"Send your guess!\" ) number = random . randint ( 1 , 10 ) guess = await bot . wait_for ( 'message' , check = lambda message : message . author == ctx . author , timeout = 3.0 ) if int ( guess . content ) == number : await ctx . send ( \"Wow! You guessed it!\" ) else : await ctx . send ( \"Wrong!\" ) More \u00b6 There are tons of things you may do. This guide can show you how to do it. What you can do, that is up to you. Make sure to learn basic Python, and you will be able to create wonders with Discord Bots. Meanwhile, here are a few ideas to get started: Coin Toss Command (Tip: Similar to the Guess the Number example.) Quotes and Jokes Command (Tip: Use an API! Learn about the requests or aiohttp module, and use an API, for example, Random Stuff API) A simple economy command! (Tip: Learn about Databases. You may learn SQL and use the aiosqlite module.) Final Code \u00b6 Here is all the code we wrote so far: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 import discord # make sure you install py-cord - read the Installation Page from discord.ext import commands # will be discussed later import os # default module from dotenv import load_dotenv # pip install python-dotenv import random # default module load_dotenv () # we load all the variables from the env file bot = commands . Bot ( command_prefix = '!' , case_insensitive = True ) @bot . event async def on_ready (): print ( f \" { bot . user } is ready and online!\" ) @bot . command () async def hello ( ctx ): await ctx . send ( \"Hey!\" ) @bot . command ( name = \"ping\" ) async def ping ( ctx ): await ctx . send ( f \"Pong! My latency is: { round ( bot . latency * 1000 ) } ms\" ) @bot . command () async def embed ( ctx ): embed = discord . Embed ( title = \"How to make embeds with Py-cord\" , description = \"This tutorial will show you how to make embeds in py-cord. Simple enough, so lets get started!\" , color = discord . Color . from_rbg ( 255 , 255 , 255 ), url = \"...\" ) embed . add_field ( name = \"With Inline\" , value = \"This is what I would look like with inline\" , inline = True ) embed . add_field ( name = \"With Inline\" , value = \"This is what I would look like with inline\" , inline = True ) embed . add_field ( name = \"With Inline\" , value = \"This is what I would look like with inline\" , inline = True ) embed . add_field ( name = \"Without Inline\" , value = \"This is what I would look like without inline\" , inline = False ) embed . add_field ( name = \"Without Inline\" , value = \"This is what I would look like without inline\" , inline = False ) embed . set_footer ( text = \"...\" , icon_url = \"...\" ) embed . set_author ( name = \"Pycord Guide\" , icon_url = '...' , url = \"...\" ) await ctx . send ( embed = embed ) @bot . command () async def gtn ( ctx ): await ctx . send ( \"Send your guess!\" ) number = random . randint ( 1 , 10 ) guess = await bot . wait_for ( 'message' , check = lambda message : message . author == ctx . author , timeout = 3.0 ) if int ( guess . content ) == number : await ctx . send ( \"Wow! You guessed it!\" ) else : await ctx . send ( \"Wrong!\" ) bot . run ( os . getenv ( 'TOKEN' ))","title":"Creating your first bot"},{"location":"Getting%20Started/coding-your-first-bot/#creating-your-first-bot","text":"","title":"Creating your first bot"},{"location":"Getting%20Started/coding-your-first-bot/#creating-the-bot","text":"Just like how you needed to sign up to Discord to get started, we need to get your bot signed up too. To do this, Go to the Discord Developer Portal and click on New Application . Give your bot a name, and click Create . Now, you should see a page like this. Click on Bot tab on the left side of the screen. Click on Add bot . You can give it a name, change the Avatar, etc.","title":"Creating the bot"},{"location":"Getting%20Started/coding-your-first-bot/#inviting-the-bot","text":"Now, lets get the bot added to some servers. Go to the OAuth2 tab in the left pane, and select bot and applications.commands as the scope. The applications.command s scope allows the bot to use Slash Commands, which you may want to have. Next, we choose what permissions the bot will have. You can select them. For now, lets give your bot the Administrator permission, meaning the bot will have all the permissions. Once you select the permissions, click on copy to get the bot invite link. You can use this link to invite the bot.","title":"Inviting the bot"},{"location":"Getting%20Started/coding-your-first-bot/#tokens","text":"Now that we have an account for our bot, we need to login. In order to login, we need the bot's password. All users and bots have a \"token\". You may think of a token as a unique password, since this is what we use to log into the bot and connect it to Discord. Tokens are \"snowflakes\". Not actual snowflakes, though. Just like how no two snowflakes in real life have the same pattern, a snowflake in computers is a unique thing - no two bots have the same token - so a token is a snowflake. An ID is a snowflake. Now, lets get our bot's token. To do this, Go back to the Bot tab. Click on the Copy button in the \"Token\" section. Now, you have your bot's token copied to your clipboard. Danger Never leak your bot's token, and never share it with anyone. Even if you get any DMs and someone tells you to do so, maybe claiming to be Discord Staff, do not do so. They are probably lying and are scamming you. Anyone with your token will be able to access your bot fully. They will be able to do anything they want with your bot. Never push it to GitHub, or send it with the code. One way to prevent your token from getting leaked is to store it in .env files.","title":"Tokens"},{"location":"Getting%20Started/coding-your-first-bot/#storing-the-token-in-an-env-file","text":"Storing your bot Token in an ENV File will increase its security, and prevent it from getting leaked. Create a file with the name .env . Just .env , with the dot/period at the start. Define the token in the file, like, 1 TOKEN = [PASTE YOUR TOKEN HERE] for example, 1 TOKEN = NzkyNzE1NDU0MTk2MDg4ODQy.X-hvzA.Ovy4MCQywSkoMRRclStW4xAYK7I","title":"Storing the token in an ENV file"},{"location":"Getting%20Started/coding-your-first-bot/#coding-the-basics","text":"Make sure to install 1 pip install python-dotenv 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 import discord # make sure you install py-cord - read the Installation Page from discord.ext import commands # will be discussed later import os # default module from dotenv import load_dotenv # pip install python-dotenv load_dotenv () # we load all the variables from the env file bot = commands . Bot ( command_prefix = '!' , case_insensitive = True ) @bot . event async def on_ready (): print ( f \" { bot . user } is ready and online!\" ) @bot . command () async def hello ( ctx ): await ctx . send ( \"Hey!\" ) bot . run ( os . getenv ( 'TOKEN' )) import discord In this line, we import the py-cord module. from discord.ext import commands Frankly speaking, the Discord API doesn't have custom commands as you'd expect. It has events, interactions, and more. Hence, many people use the on_message event, which is triggered every time someone sends a message. To make commands, you need to use an extension called commands. Its installed with the library, so no worries! bot = commands.Bot(command_prefix='!', case_insensitive=True) We create an instance of Bot. This connects us to Discord. @bot.event The @bot.event() decorator is used to register an event. This is an asynchronous library, so things are done with callbacks. A callback is a function that is called when something else happens. In this code, the on_ready() event is called when the bot is ready to start being used. We use the @bot.command() decorator to register a command. The callback also becomes the name of the command. In the next lines, we send \"Hey!\" to the user. bot.run(os.getenv('TOKEN')) We get our token from the .env file, and login to Discord Run the bot, and you will have your first bot!","title":"Coding the Basics"},{"location":"Getting%20Started/coding-your-first-bot/#making-more-commands","text":"","title":"Making more commands"},{"location":"Getting%20Started/coding-your-first-bot/#ping","text":"\"Ping\" or \"Latency\" of the bot is the time it takes to respond to your commands. The less the ping, the better! Ping is calculated in milli seconds, and here's how you can create a cool ping command. 1 2 3 @bot . command ( name = \"ping\" ) async def ping ( ctx ): await ctx . send ( f \"Pong! My latency is: { round ( bot . latency * 1000 ) } ms\" ) A latency of about 300ms is common if you are running the bot from your PC. You may get a better ping by hosting the bot. The top bots pay for the best servers and get a ping of about 10-30ms. Thats 0.04 seconds!","title":"Ping"},{"location":"Getting%20Started/coding-your-first-bot/#embeds","text":"Embeds can make your bot's messages look a lot cooler. It also has other purposes, like fending off imposers - for example, people used to impersonate Dank Memer and trick users into giving them their items. Seeing this, the developers decided to use embeds - since embeds can only be sent by bots and webhooks, no users could impersonate any longer. So, its clear that embeds are pretty nice. Adding them is simple enough too! 1 2 3 4 @bot . command () async def embed ( ctx ): embed = discord . Embed ( title = \"How to make embeds with Py-cord\" , description = \"This tutorial will show you how to make embeds in py-cord. Simple enough, so lets get started!\" , color = discord . Color . from_rbg ( 255 , 255 , 255 )) await ctx . send ( embed = embed ) Fields 1 2 3 4 5 6 7 8 9 @bot . command () async def embed ( ctx ): embed = discord . Embed ( title = \"How to make embeds with Py-cord\" , description = \"This tutorial will show you how to make embeds in py-cord. Simple enough, so lets get started!\" , color = discord . Color . from_rbg ( 255 , 255 , 255 )) embed . add_field ( name = \"With Inline\" , value = \"This is what I would look like with inline\" , inline = True ) embed . add_field ( name = \"With Inline\" , value = \"This is what I would look like with inline\" , inline = True ) embed . add_field ( name = \"With Inline\" , value = \"This is what I would look like with inline\" , inline = True ) embed . add_field ( name = \"Without Inline\" , value = \"This is what I would look like without inline\" , inline = False ) embed . add_field ( name = \"Without Inline\" , value = \"This is what I would look like without inline\" , inline = False ) await ctx . send ( embed = embed ) Headers and Footers 1 2 3 4 5 6 7 8 9 10 11 12 13 14 @bot . command () async def embed ( ctx ): embed = discord . Embed ( title = \"How to make embeds with Py-cord\" , description = \"This tutorial will show you how to make embeds in py-cord. Simple enough, so lets get started!\" , color = discord . Color . from_rbg ( 255 , 255 , 255 ), url = \"...\" ) embed . add_field ( name = \"With Inline\" , value = \"This is what I would look like with inline\" , inline = True ) embed . add_field ( name = \"With Inline\" , value = \"This is what I would look like with inline\" , inline = True ) embed . add_field ( name = \"With Inline\" , value = \"This is what I would look like with inline\" , inline = True ) embed . add_field ( name = \"Without Inline\" , value = \"This is what I would look like without inline\" , inline = False ) embed . add_field ( name = \"Without Inline\" , value = \"This is what I would look like without inline\" , inline = False ) embed . set_footer ( text = \"...\" , icon_url = \"...\" ) embed . set_author ( name = \"Pycord Guide\" , icon_url = '...' , url = \"...\" ) await ctx . send ( embed = embed ) embed . set_footer ( ... , icon_url = ctx . author . avatar_url )","title":"Embeds"},{"location":"Getting%20Started/coding-your-first-bot/#user-input","text":"You may want to make commands that require the user to say something, for example, Guess the Number commands. Let's see how you can allow the user to be able to send their own input to the bot.","title":"User Input"},{"location":"Getting%20Started/coding-your-first-bot/#args","text":"In this kind of input, the user will be able to provide the input with the command itself, for example, !gtn 5 . 1 2 3 4 5 6 7 8 9 import random @bot . command () async def gtn ( ctx , guess : int ): number = random . randint ( 1 , 10 ) if guess == number : await ctx . send ( \"You guessed it!) else : await ctx . send ( \"Nope! Better luck next time :)\" ) Code Explanation async def gtn(ctx, guess:int): We set guess as a number parameter. However, if the user enters a value as !gtn 5 5 , it will only take 5 as the input, splitting at spaces. To take the rest of the text as input too, you may use async def gtn(ctx, *, guess:int): instead. This is useful when the args is a string, for example, a feedback command. number = random.randint(1, 10) Using the random module, we generate a random number between 1 to 10. 6 7 8 9 if guess == number : await ctx . send ( \"You guessed it!) else : await ctx . send ( \"Nope! Better luck next time :)\" ) We check if the user's guess was the same as the number that was generated, and inform them if they were right or wrong.","title":"Args"},{"location":"Getting%20Started/coding-your-first-bot/#wait-for","text":"We may want to provide multiple chances to the user, and in this case, args and parameters will not be useful. Instead, we will need to use wait_for . 1 2 3 4 5 6 7 8 9 10 11 import random @bot . command () async def gtn ( ctx ): await ctx . send ( \"Send your guess!\" ) number = random . randint ( 1 , 10 ) guess = await bot . wait_for ( 'message' , check = lambda message : message . author == ctx . author , timeout = 3.0 ) if int ( guess . content ) == number : await ctx . send ( \"Wow! You guessed it!\" ) else : await ctx . send ( \"Wrong!\" )","title":"Wait for"},{"location":"Getting%20Started/coding-your-first-bot/#more","text":"There are tons of things you may do. This guide can show you how to do it. What you can do, that is up to you. Make sure to learn basic Python, and you will be able to create wonders with Discord Bots. Meanwhile, here are a few ideas to get started: Coin Toss Command (Tip: Similar to the Guess the Number example.) Quotes and Jokes Command (Tip: Use an API! Learn about the requests or aiohttp module, and use an API, for example, Random Stuff API) A simple economy command! (Tip: Learn about Databases. You may learn SQL and use the aiosqlite module.)","title":"More"},{"location":"Getting%20Started/coding-your-first-bot/#final-code","text":"Here is all the code we wrote so far: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 import discord # make sure you install py-cord - read the Installation Page from discord.ext import commands # will be discussed later import os # default module from dotenv import load_dotenv # pip install python-dotenv import random # default module load_dotenv () # we load all the variables from the env file bot = commands . Bot ( command_prefix = '!' , case_insensitive = True ) @bot . event async def on_ready (): print ( f \" { bot . user } is ready and online!\" ) @bot . command () async def hello ( ctx ): await ctx . send ( \"Hey!\" ) @bot . command ( name = \"ping\" ) async def ping ( ctx ): await ctx . send ( f \"Pong! My latency is: { round ( bot . latency * 1000 ) } ms\" ) @bot . command () async def embed ( ctx ): embed = discord . Embed ( title = \"How to make embeds with Py-cord\" , description = \"This tutorial will show you how to make embeds in py-cord. Simple enough, so lets get started!\" , color = discord . Color . from_rbg ( 255 , 255 , 255 ), url = \"...\" ) embed . add_field ( name = \"With Inline\" , value = \"This is what I would look like with inline\" , inline = True ) embed . add_field ( name = \"With Inline\" , value = \"This is what I would look like with inline\" , inline = True ) embed . add_field ( name = \"With Inline\" , value = \"This is what I would look like with inline\" , inline = True ) embed . add_field ( name = \"Without Inline\" , value = \"This is what I would look like without inline\" , inline = False ) embed . add_field ( name = \"Without Inline\" , value = \"This is what I would look like without inline\" , inline = False ) embed . set_footer ( text = \"...\" , icon_url = \"...\" ) embed . set_author ( name = \"Pycord Guide\" , icon_url = '...' , url = \"...\" ) await ctx . send ( embed = embed ) @bot . command () async def gtn ( ctx ): await ctx . send ( \"Send your guess!\" ) number = random . randint ( 1 , 10 ) guess = await bot . wait_for ( 'message' , check = lambda message : message . author == ctx . author , timeout = 3.0 ) if int ( guess . content ) == number : await ctx . send ( \"Wow! You guessed it!\" ) else : await ctx . send ( \"Wrong!\" ) bot . run ( os . getenv ( 'TOKEN' ))","title":"Final Code"},{"location":"Getting%20Started/cogs/","text":"Cogs \u00b6 You must have seen \"modules\" listed in a bot's help command. These are called \"cogs\". Instead of having all your code in the Main file, you can create Cogs for each type of command. For example, meme and anime commands go to a Fun cog, help and ping to Misc , and so on. But how do you create Cogs in the first place? Well, lets learn! First, lets create a folder named \" cogs \". This is where we will store different Cogs. Next, create a file in the folder with the name of the cog - for example, greetings.py . Now, lets get coding. greetings.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 import discord from discord.ext import commands class Greetings ( commands . Cog , name = \"Greetings\" ): # We Subclass commands.Cog . if the name kwarg is not passed, the Cog name is taken to be the same as the class name def __init__ ( self , bot ): self . bot = bot @commands . Cog . listener () # just like @bot.event async def on_member_join ( self , member ): # called when a member joins channel = member . guild . system_channel # get the guild's system messages channel - where welcome and boost messages are sent. You can change this to bot.get_channel(channel_id) if channel is not None : await channel . send ( 'Welcome {0.mention} .' . format ( member )) @commands . command () # this is how you create a command in a Cog. The same as @bot.command() async def hello ( self , ctx , * , member : discord . Member = None ): # always remember to pass \"self\"! \"\"\"Says hello\"\"\" # command description member = member or ctx . author await ctx . send ( 'Hello {0.name} ~' . format ( member )) def setup ( bot ): bot . add_cog ( Greetings ( bot )) # register the cog Now, lets add some things in main.py / bot.py /your main bot file. bot.py 1 2 3 4 5 6 bot . load_extension ( 'cogs.greetings' ) # cogs_folder.filename # OR, if you want to load multiple cogs, its better to use: for ext in [ 'cogs.greetings' , 'cogs.fun' , 'cogs.anime' ]: bot . load_extension ( ext ) And that's it! You have your first Cog! Of course, you can do a lot more things, but for that you need to Read the Docs","title":"Cogs"},{"location":"Getting%20Started/cogs/#cogs","text":"You must have seen \"modules\" listed in a bot's help command. These are called \"cogs\". Instead of having all your code in the Main file, you can create Cogs for each type of command. For example, meme and anime commands go to a Fun cog, help and ping to Misc , and so on. But how do you create Cogs in the first place? Well, lets learn! First, lets create a folder named \" cogs \". This is where we will store different Cogs. Next, create a file in the folder with the name of the cog - for example, greetings.py . Now, lets get coding. greetings.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 import discord from discord.ext import commands class Greetings ( commands . Cog , name = \"Greetings\" ): # We Subclass commands.Cog . if the name kwarg is not passed, the Cog name is taken to be the same as the class name def __init__ ( self , bot ): self . bot = bot @commands . Cog . listener () # just like @bot.event async def on_member_join ( self , member ): # called when a member joins channel = member . guild . system_channel # get the guild's system messages channel - where welcome and boost messages are sent. You can change this to bot.get_channel(channel_id) if channel is not None : await channel . send ( 'Welcome {0.mention} .' . format ( member )) @commands . command () # this is how you create a command in a Cog. The same as @bot.command() async def hello ( self , ctx , * , member : discord . Member = None ): # always remember to pass \"self\"! \"\"\"Says hello\"\"\" # command description member = member or ctx . author await ctx . send ( 'Hello {0.name} ~' . format ( member )) def setup ( bot ): bot . add_cog ( Greetings ( bot )) # register the cog Now, lets add some things in main.py / bot.py /your main bot file. bot.py 1 2 3 4 5 6 bot . load_extension ( 'cogs.greetings' ) # cogs_folder.filename # OR, if you want to load multiple cogs, its better to use: for ext in [ 'cogs.greetings' , 'cogs.fun' , 'cogs.anime' ]: bot . load_extension ( ext ) And that's it! You have your first Cog! Of course, you can do a lot more things, but for that you need to Read the Docs","title":"Cogs"},{"location":"Guides/Context%20Menu%20Commands/","text":"Context Menu Commands \u00b6 What are User Commands and Message Commands? \u00b6 When you right click a message, you may see a option called \"Apps\". Hover over it and you can see commands a bot can run with that message. These are called message commands. When you right click a message in the user list, you can once again see an option called \"Apps\". Hover over it and you can see commands a bot can run with that message. These are called user commands. Creating User Commands \u00b6 1 2 3 @bot . user_command ( guild_ids = [ ... ]) # create a user command for the supplied guilds async def mention ( ctx , member : discord . Member ): # user commands return the member await ctx . respond ( f \" { ctx . author . name } just mentioned { member . mention } !\" ) If you want to make the command global, remove guild_ids. Note that global application commands can take up to an hour to register. Creating Message Commands \u00b6 Similar to user commands, 1 2 3 @bot . message_command ( name = \"Show ID\" ) # creates a global message command. use guild_ids=[] to create guild-specific commands. async def show_id ( ctx , message : discord . Message ): # message commands return the message await ctx . respond ( f \" { ctx . author . name } , here's the message id: { message . id } !\" )","title":"Context Menu Commands"},{"location":"Guides/Context%20Menu%20Commands/#context-menu-commands","text":"","title":"Context Menu Commands"},{"location":"Guides/Context%20Menu%20Commands/#what-are-user-commands-and-message-commands","text":"When you right click a message, you may see a option called \"Apps\". Hover over it and you can see commands a bot can run with that message. These are called message commands. When you right click a message in the user list, you can once again see an option called \"Apps\". Hover over it and you can see commands a bot can run with that message. These are called user commands.","title":"What are User Commands and Message Commands?"},{"location":"Guides/Context%20Menu%20Commands/#creating-user-commands","text":"1 2 3 @bot . user_command ( guild_ids = [ ... ]) # create a user command for the supplied guilds async def mention ( ctx , member : discord . Member ): # user commands return the member await ctx . respond ( f \" { ctx . author . name } just mentioned { member . mention } !\" ) If you want to make the command global, remove guild_ids. Note that global application commands can take up to an hour to register.","title":"Creating User Commands"},{"location":"Guides/Context%20Menu%20Commands/#creating-message-commands","text":"Similar to user commands, 1 2 3 @bot . message_command ( name = \"Show ID\" ) # creates a global message command. use guild_ids=[] to create guild-specific commands. async def show_id ( ctx , message : discord . Message ): # message commands return the message await ctx . respond ( f \" { ctx . author . name } , here's the message id: { message . id } !\" )","title":"Creating Message Commands"},{"location":"Guides/buttons/","text":"Buttons \u00b6 Read the Docs Usage \u00b6 Subclassing discord.ui.View \u00b6 In order to make a proper button which does something on click, you may need to use this method. By subclassing, we mean that our class gets all the attributes of discord.ui.View . Here's an example of a simple button. 1 2 3 4 5 6 7 8 class MyView ( discord . ui . View ): @discord . ui . button ( label = 'A button' , style = discord . ButtonStyle . primary , emoji = '\ud83d\ude0e' ) async def button_callback ( self , button , interaction ): await interaction . response . send_message ( 'Button was pressed' , ephemeral = True ) @bot . command () async def button ( ctx ): await ctx . send ( 'Press the button!' , view = MyView ()) Subclassing discord.ui.Button \u00b6 We may use this instead of subclassing discord.ui.View . 1 2 3 4 5 6 7 8 9 10 11 class MyButton ( discord . ui . Button ): def __init__ ( self ): super () . __init__ ( label = 'A button' , style = discord . ButtonStyle . primary ) async def callback ( self , interaction ): await interaction . response . send_message ( 'Button was pressed' , ephemeral = True ) view = discord . ui . View () view . add_item ( MyButton ()) @bot . command () async def ctx . send ( 'Press the button!' , view = view ) However, this method can become way longer. Using buttons without subclassing \u00b6 You CAN send buttons without subclassing them, however, they won't be able to have a callback. They won't be able to respond. Thankfully, in URL Buttons, we don't need to respond, so we can this method. 1 2 view = discord . ui . View () view . add_item ( discord . ui . Button ( label = 'Go to website' , url = 'https://gist.github.com/MhmCats/500eafdad0aaf278b94c612764688976' , style = discord . ButtonStyle . url )) Styles \u00b6 Name Usage Color Primary discord.ButtonStyle.primary Blurple Secondary discord.ButtonStyle.secondary Grey Success discord.ButtonStyle.success Green Danger discord.ButtonStyle.danger Red Link discord.ButtonStyle.link Grey Timeouts \u00b6 You may want to set timeouts, so that after a certain time, the buttons will stop working. Its quite easy! 1 2 3 4 5 6 7 8 class MyView ( discord . ui . View ): @discord . ui . button ( label = 'A button' , style = discord . ButtonStyle . primary , emoji = '\ud83d\ude0e' ) async def button_callback ( self , button , interaction ): await interaction . response . send_message ( 'Button was pressed' , ephemeral = True ) @bot . command () async def button ( ctx ): await ctx . send ( 'Press the button!' , view = MyView ( timeout = 30 )) This will stop the button from working after 30 seconds, however, the button will simply stop working, and if someone tries to use it, it will simply show \"Interaction Failed\". You might want to replace it with a custom message, and perhaps disable the buttons too! 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class MyView ( discord . ui . View ): def __init__ ( self ): super () . __init__ ( timeout = 10 ) async def on_timeout ( self ): for child in self . children : child . disabled = True await self . message . edit ( content = \"You took too long!\" , view = self ) @discord . ui . button ( style = discord . ButtonStyle . primary ) async def callback ( self , button , interaction ): await interaction . response . send_message ( 'Button was pressed' , ephemeral = True ) @bot . command () async def hi ( ctx ): view = MyView () view . message = await ctx . send ( \"hi\" , view = view ) Action Rows \u00b6 A message can have up to five \"action rows\" and each of these \"action\" rows have five slots where you can put message components. A button takes up one of these slots but a select menus takes up all five slots of a \"action row\". Keep this in mind when creating your views since you don't want to run out of space! Action rows are handled internally, and you can pass the row kwarg to use them. Example: 1 2 3 4 5 6 7 8 9 10 11 12 class MyView ( discord . ui . View ): @discord . ui . button ( label = \"Button 1\" , row = 1 , style = discord . ButtonStyle . primary ) async def first_button_callback ( self , button , interaction ): await interaction . response . send_message ( \"You pressed me!\" ) @discord . ui . button ( label = \"Button 2\" , row = 2 , style = discord . ButtonStyle . primary ) async def second_button_callback ( self , button , interaction ): await interaction . response . send_message ( \"You pressed me!\" ) @bot . command () async def button ( ctx ): view . message = await ctx . send ( \"Wow!\" , view = MyView ()) Persistent Views \u00b6 When your bot goes offline, all active buttons will become useless, like a remove that does nothing. You will be able to see the buttons, but nothing will happen when you press them. If you are trying to make self roles with buttons, then it will be useless! This is where Persistent Views step in. Persistent views will keep responding forever - if the bot goes offline, it will just hibernate. When it comes back online, it will start working again! These views have no timeout, and are active forever. Persistent Views have no timeout, and all items in them have a custom_id set. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 @bot . event async def on_ready (): bot . add_view ( MyView ()) class MyView ( discord . ui . View ): def __init__ ( self ): super () . __init__ ( timeout = None ) @discord . ui . button ( label = 'A button' , custom_id = \"button-1\" , style = discord . ButtonStyle . primary , emoji = '\ud83d\ude0e' ) async def button_callback ( self , button , interaction ): await interaction . response . send_message ( 'Button was pressed' , ephemeral = True ) @bot . command () async def button ( ctx ): await ctx . send ( f 'Press the button! Is Persistent: { MyView . is_persistent ( MyView ()) } ' , view = MyView ()) Disabling Buttons \u00b6 Making Pre-Disabled Buttons \u00b6 1 2 3 4 5 6 7 8 class MyView ( discord . ui . View ): @discord . ui . button ( label = 'A button' , style = discord . ButtonStyle . primary , disabled = True ) async def button_callback ( self , button , interaction ): ... @bot . command () async def button ( ctx ): await ctx . send ( 'Press the button!' , view = MyView ()) Disabling Buttons on Press \u00b6 Disabling a single button 1 2 3 4 5 6 7 8 9 10 11 class MyView ( discord . ui . View ): @discord . ui . button ( label = 'A button' , style = discord . ButtonStyle . primary ) async def button_callback ( self , button , interaction ): button . disabled = True button . label = 'No more pressing!' await interaction . response . edit_message ( view = self ) view = MyView () @bot . command () async def button ( ctx ): await ctx . send ( 'Press the button!' , view = view ) Disabling all buttons 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class MyView ( discord . ui . View ): @discord . ui . button ( emoji = '\ud83d\ude00' , label = \"Button 1\" , style = discord . ButtonStyle . primary ) async def button_callback ( self , button , interaction ): for child in self . children : child . disabled = True button . label = 'No more pressing either button!' await interaction . response . edit_message ( view = self ) @discord . ui . button ( label = \"Button 2\" , style = discord . ButtonStyle . primary ) async def second_button_callback ( self , button , interaction ): for child in self . children : child . disabled = True button . label = 'No more pressing either button!' await interaction . response . edit_message ( view = self ) @bot . command () async def button ( ctx ): await ctx . send ( content = \"Press the button!\" , view = MyView ())","title":"Buttons"},{"location":"Guides/buttons/#buttons","text":"Read the Docs","title":"Buttons"},{"location":"Guides/buttons/#usage","text":"","title":"Usage"},{"location":"Guides/buttons/#subclassing-discorduiview","text":"In order to make a proper button which does something on click, you may need to use this method. By subclassing, we mean that our class gets all the attributes of discord.ui.View . Here's an example of a simple button. 1 2 3 4 5 6 7 8 class MyView ( discord . ui . View ): @discord . ui . button ( label = 'A button' , style = discord . ButtonStyle . primary , emoji = '\ud83d\ude0e' ) async def button_callback ( self , button , interaction ): await interaction . response . send_message ( 'Button was pressed' , ephemeral = True ) @bot . command () async def button ( ctx ): await ctx . send ( 'Press the button!' , view = MyView ())","title":"Subclassing discord.ui.View"},{"location":"Guides/buttons/#subclassing-discorduibutton","text":"We may use this instead of subclassing discord.ui.View . 1 2 3 4 5 6 7 8 9 10 11 class MyButton ( discord . ui . Button ): def __init__ ( self ): super () . __init__ ( label = 'A button' , style = discord . ButtonStyle . primary ) async def callback ( self , interaction ): await interaction . response . send_message ( 'Button was pressed' , ephemeral = True ) view = discord . ui . View () view . add_item ( MyButton ()) @bot . command () async def ctx . send ( 'Press the button!' , view = view ) However, this method can become way longer.","title":"Subclassing discord.ui.Button"},{"location":"Guides/buttons/#using-buttons-without-subclassing","text":"You CAN send buttons without subclassing them, however, they won't be able to have a callback. They won't be able to respond. Thankfully, in URL Buttons, we don't need to respond, so we can this method. 1 2 view = discord . ui . View () view . add_item ( discord . ui . Button ( label = 'Go to website' , url = 'https://gist.github.com/MhmCats/500eafdad0aaf278b94c612764688976' , style = discord . ButtonStyle . url ))","title":"Using buttons without subclassing"},{"location":"Guides/buttons/#styles","text":"Name Usage Color Primary discord.ButtonStyle.primary Blurple Secondary discord.ButtonStyle.secondary Grey Success discord.ButtonStyle.success Green Danger discord.ButtonStyle.danger Red Link discord.ButtonStyle.link Grey","title":"Styles"},{"location":"Guides/buttons/#timeouts","text":"You may want to set timeouts, so that after a certain time, the buttons will stop working. Its quite easy! 1 2 3 4 5 6 7 8 class MyView ( discord . ui . View ): @discord . ui . button ( label = 'A button' , style = discord . ButtonStyle . primary , emoji = '\ud83d\ude0e' ) async def button_callback ( self , button , interaction ): await interaction . response . send_message ( 'Button was pressed' , ephemeral = True ) @bot . command () async def button ( ctx ): await ctx . send ( 'Press the button!' , view = MyView ( timeout = 30 )) This will stop the button from working after 30 seconds, however, the button will simply stop working, and if someone tries to use it, it will simply show \"Interaction Failed\". You might want to replace it with a custom message, and perhaps disable the buttons too! 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class MyView ( discord . ui . View ): def __init__ ( self ): super () . __init__ ( timeout = 10 ) async def on_timeout ( self ): for child in self . children : child . disabled = True await self . message . edit ( content = \"You took too long!\" , view = self ) @discord . ui . button ( style = discord . ButtonStyle . primary ) async def callback ( self , button , interaction ): await interaction . response . send_message ( 'Button was pressed' , ephemeral = True ) @bot . command () async def hi ( ctx ): view = MyView () view . message = await ctx . send ( \"hi\" , view = view )","title":"Timeouts"},{"location":"Guides/buttons/#action-rows","text":"A message can have up to five \"action rows\" and each of these \"action\" rows have five slots where you can put message components. A button takes up one of these slots but a select menus takes up all five slots of a \"action row\". Keep this in mind when creating your views since you don't want to run out of space! Action rows are handled internally, and you can pass the row kwarg to use them. Example: 1 2 3 4 5 6 7 8 9 10 11 12 class MyView ( discord . ui . View ): @discord . ui . button ( label = \"Button 1\" , row = 1 , style = discord . ButtonStyle . primary ) async def first_button_callback ( self , button , interaction ): await interaction . response . send_message ( \"You pressed me!\" ) @discord . ui . button ( label = \"Button 2\" , row = 2 , style = discord . ButtonStyle . primary ) async def second_button_callback ( self , button , interaction ): await interaction . response . send_message ( \"You pressed me!\" ) @bot . command () async def button ( ctx ): view . message = await ctx . send ( \"Wow!\" , view = MyView ())","title":"Action Rows"},{"location":"Guides/buttons/#persistent-views","text":"When your bot goes offline, all active buttons will become useless, like a remove that does nothing. You will be able to see the buttons, but nothing will happen when you press them. If you are trying to make self roles with buttons, then it will be useless! This is where Persistent Views step in. Persistent views will keep responding forever - if the bot goes offline, it will just hibernate. When it comes back online, it will start working again! These views have no timeout, and are active forever. Persistent Views have no timeout, and all items in them have a custom_id set. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 @bot . event async def on_ready (): bot . add_view ( MyView ()) class MyView ( discord . ui . View ): def __init__ ( self ): super () . __init__ ( timeout = None ) @discord . ui . button ( label = 'A button' , custom_id = \"button-1\" , style = discord . ButtonStyle . primary , emoji = '\ud83d\ude0e' ) async def button_callback ( self , button , interaction ): await interaction . response . send_message ( 'Button was pressed' , ephemeral = True ) @bot . command () async def button ( ctx ): await ctx . send ( f 'Press the button! Is Persistent: { MyView . is_persistent ( MyView ()) } ' , view = MyView ())","title":"Persistent Views"},{"location":"Guides/buttons/#disabling-buttons","text":"","title":"Disabling Buttons"},{"location":"Guides/buttons/#making-pre-disabled-buttons","text":"1 2 3 4 5 6 7 8 class MyView ( discord . ui . View ): @discord . ui . button ( label = 'A button' , style = discord . ButtonStyle . primary , disabled = True ) async def button_callback ( self , button , interaction ): ... @bot . command () async def button ( ctx ): await ctx . send ( 'Press the button!' , view = MyView ())","title":"Making Pre-Disabled Buttons"},{"location":"Guides/buttons/#disabling-buttons-on-press","text":"Disabling a single button 1 2 3 4 5 6 7 8 9 10 11 class MyView ( discord . ui . View ): @discord . ui . button ( label = 'A button' , style = discord . ButtonStyle . primary ) async def button_callback ( self , button , interaction ): button . disabled = True button . label = 'No more pressing!' await interaction . response . edit_message ( view = self ) view = MyView () @bot . command () async def button ( ctx ): await ctx . send ( 'Press the button!' , view = view ) Disabling all buttons 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class MyView ( discord . ui . View ): @discord . ui . button ( emoji = '\ud83d\ude00' , label = \"Button 1\" , style = discord . ButtonStyle . primary ) async def button_callback ( self , button , interaction ): for child in self . children : child . disabled = True button . label = 'No more pressing either button!' await interaction . response . edit_message ( view = self ) @discord . ui . button ( label = \"Button 2\" , style = discord . ButtonStyle . primary ) async def second_button_callback ( self , button , interaction ): for child in self . children : child . disabled = True button . label = 'No more pressing either button!' await interaction . response . edit_message ( view = self ) @bot . command () async def button ( ctx ): await ctx . send ( content = \"Press the button!\" , view = MyView ())","title":"Disabling Buttons on Press"},{"location":"Guides/dropdowns/","text":"Dropdowns \u00b6 Read the docs Min Values: The Minimum number of values the user must select. A user can select multiple values in a select menu. If you want the user to be able to select only one option, set both min values and max values to 1. Max Values: The Minimum number of values the user can select. A user can select multiple values in a select menu. If you want the user to be able to select only one option, set both min values and max values to 1. Placeholder: The text to be displayed when no option is selected. Usage \u00b6 Subclassing discord.ui.View \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 class MyView ( discord . ui . View ): @discord . ui . select ( placeholder = 'Pick your colour' , min_values = 1 , max_values = 1 , options = [ discord . SelectOption ( label = 'Red' , description = 'Your favourite colour is red' , emoji = '\ud83d\udfe5' ), discord . SelectOption ( label = 'Green' , description = 'Your favourite colour is green' , emoji = '\ud83d\udfe9' ), discord . SelectOption ( label = 'Blue' , description = 'Your favourite colour is blue' , emoji = '\ud83d\udfe6' ) ]) async def select_callback ( self , select , interaction ): await interaction . response . send_message ( f 'Your favourite colour is { select . values [ 0 ] } ' , ephemeral = True ) @bot . command () async def my_select ( ctx ): await ctx . send ( 'What is your favourite colour?' , view = MyView ( timeout = 0 )) Subclassing discord.ui.Select \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class MySelect ( discord . ui . Select ): def __init__ ( self ): options = [ discord . SelectOption ( label = 'Red' , description = 'Your favourite colour is red' , emoji = '\ud83d\udfe5' ), discord . SelectOption ( label = 'Green' , description = 'Your favourite colour is green' , emoji = '\ud83d\udfe9' ), discord . SelectOption ( label = 'Blue' , description = 'Your favourite colour is blue' , emoji = '\ud83d\udfe6' ) ] super () . __init__ ( placeholder = 'Pick your colour' , min_values = 1 , max_values = 1 , options = options ) async def callback ( self , interaction ): await interaction . response . send_message ( f 'Your favourite colour is { self . values [ 0 ] } ' , ephemeral = True ) view = discord . ui . View ( timeout = 10 ) # timeout is optional, it can be defined in seconds view . add_item ( MySelect ()) @bot . command () async def my_select ( ctx ): await ctx . send ( 'What is your favourite colour?' , view = view ) Action Rows \u00b6 A message can have up to five \"action rows\" and each of these \"action\" rows have five slots where you can put message components. A button takes up one of these slots but a select menus takes up all five slots of a \"action row\". Keep this in mind when creating your views since you don't want to run out of space! Action rows are handled internally, and you can pass the row kwarg to use them, thr same way you use them with buttons . Persistent Views \u00b6 When your bot goes offline, all active buttons will become useless, like a remove that does nothing. You will be able to see the buttons, but nothing will happen when you press them. If you are trying to make self roles with buttons, then it will be useless! This is where Persistent Views step in. Persistent views will keep responding forever - if the bot goes offline, it will just hibernate. When it comes back online, it will start working again! These views have no timeout, and are active forever. Persistent Views have no timeout, and all items in them have a custom_id set. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 @bot . event async def on_ready (): bot . add_view ( MyView ()) class MyView ( discord . ui . View ): def __init__ ( self ): super () . __init__ ( timeout = None ) @discord . ui . select ( custom_ids = \"select-1\" , placeholder = 'Pick your colour' , min_values = 1 , max_values = 1 , options = [ discord . SelectOption ( label = 'Red' , description = 'Your favourite colour is red' , emoji = '\ud83d\udfe5' ), discord . SelectOption ( label = 'Green' , description = 'Your favourite colour is green' , emoji = '\ud83d\udfe9' ), discord . SelectOption ( label = 'Blue' , description = 'Your favourite colour is blue' , emoji = '\ud83d\udfe6' ) ]) async def select_callback ( self , select , interaction ): await interaction . response . send_message ( f 'Your favorite color is { select . values [ 0 ] } ' , ephemeral = True ) @bot . command () async def my_select ( ctx ): await ctx . send ( 'What is your favorite color?' , view = MyView ())","title":"Dropdowns"},{"location":"Guides/dropdowns/#dropdowns","text":"Read the docs Min Values: The Minimum number of values the user must select. A user can select multiple values in a select menu. If you want the user to be able to select only one option, set both min values and max values to 1. Max Values: The Minimum number of values the user can select. A user can select multiple values in a select menu. If you want the user to be able to select only one option, set both min values and max values to 1. Placeholder: The text to be displayed when no option is selected.","title":"Dropdowns"},{"location":"Guides/dropdowns/#usage","text":"","title":"Usage"},{"location":"Guides/dropdowns/#subclassing-discorduiview","text":"1 2 3 4 5 6 7 8 9 10 11 12 class MyView ( discord . ui . View ): @discord . ui . select ( placeholder = 'Pick your colour' , min_values = 1 , max_values = 1 , options = [ discord . SelectOption ( label = 'Red' , description = 'Your favourite colour is red' , emoji = '\ud83d\udfe5' ), discord . SelectOption ( label = 'Green' , description = 'Your favourite colour is green' , emoji = '\ud83d\udfe9' ), discord . SelectOption ( label = 'Blue' , description = 'Your favourite colour is blue' , emoji = '\ud83d\udfe6' ) ]) async def select_callback ( self , select , interaction ): await interaction . response . send_message ( f 'Your favourite colour is { select . values [ 0 ] } ' , ephemeral = True ) @bot . command () async def my_select ( ctx ): await ctx . send ( 'What is your favourite colour?' , view = MyView ( timeout = 0 ))","title":"Subclassing discord.ui.View"},{"location":"Guides/dropdowns/#subclassing-discorduiselect","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class MySelect ( discord . ui . Select ): def __init__ ( self ): options = [ discord . SelectOption ( label = 'Red' , description = 'Your favourite colour is red' , emoji = '\ud83d\udfe5' ), discord . SelectOption ( label = 'Green' , description = 'Your favourite colour is green' , emoji = '\ud83d\udfe9' ), discord . SelectOption ( label = 'Blue' , description = 'Your favourite colour is blue' , emoji = '\ud83d\udfe6' ) ] super () . __init__ ( placeholder = 'Pick your colour' , min_values = 1 , max_values = 1 , options = options ) async def callback ( self , interaction ): await interaction . response . send_message ( f 'Your favourite colour is { self . values [ 0 ] } ' , ephemeral = True ) view = discord . ui . View ( timeout = 10 ) # timeout is optional, it can be defined in seconds view . add_item ( MySelect ()) @bot . command () async def my_select ( ctx ): await ctx . send ( 'What is your favourite colour?' , view = view )","title":"Subclassing discord.ui.Select"},{"location":"Guides/dropdowns/#action-rows","text":"A message can have up to five \"action rows\" and each of these \"action\" rows have five slots where you can put message components. A button takes up one of these slots but a select menus takes up all five slots of a \"action row\". Keep this in mind when creating your views since you don't want to run out of space! Action rows are handled internally, and you can pass the row kwarg to use them, thr same way you use them with buttons .","title":"Action Rows"},{"location":"Guides/dropdowns/#persistent-views","text":"When your bot goes offline, all active buttons will become useless, like a remove that does nothing. You will be able to see the buttons, but nothing will happen when you press them. If you are trying to make self roles with buttons, then it will be useless! This is where Persistent Views step in. Persistent views will keep responding forever - if the bot goes offline, it will just hibernate. When it comes back online, it will start working again! These views have no timeout, and are active forever. Persistent Views have no timeout, and all items in them have a custom_id set. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 @bot . event async def on_ready (): bot . add_view ( MyView ()) class MyView ( discord . ui . View ): def __init__ ( self ): super () . __init__ ( timeout = None ) @discord . ui . select ( custom_ids = \"select-1\" , placeholder = 'Pick your colour' , min_values = 1 , max_values = 1 , options = [ discord . SelectOption ( label = 'Red' , description = 'Your favourite colour is red' , emoji = '\ud83d\udfe5' ), discord . SelectOption ( label = 'Green' , description = 'Your favourite colour is green' , emoji = '\ud83d\udfe9' ), discord . SelectOption ( label = 'Blue' , description = 'Your favourite colour is blue' , emoji = '\ud83d\udfe6' ) ]) async def select_callback ( self , select , interaction ): await interaction . response . send_message ( f 'Your favorite color is { select . values [ 0 ] } ' , ephemeral = True ) @bot . command () async def my_select ( ctx ): await ctx . send ( 'What is your favorite color?' , view = MyView ())","title":"Persistent Views"},{"location":"Guides/slash-commands/","text":"Slash Commands \u00b6 This page will show you how to use Slash Commands with Pycord. Important To create commands in a guild, your app must be authorized with the applications.commands scope. In order to make commands work within a guild, the guild must authorize your application with the applications.commands scope. The bot scope is not enough. Read the Docs A simple Slash Command \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 import discord from discord.app import Option bot = discord . Bot () # Note: If you want you can use commands.Bot instead of discord.Bot # Use discord.Bot if you don't want prefixed message commands # With discord.Bot you can use @bot.command as an alias # of @bot.slash_command but this is overriden by commands.Bot @bot . slash_command ( guild_ids = [ ... ], name = 'hello' , description = 'Say Hello!' ) # create a slash command for the supplied guilds async def hello ( ctx ): \"\"\"Say hello to the bot\"\"\" # the command description can be supplied as the docstring await ctx . respond ( f \"Hello { ctx . author } !\" ) bot . run ( \"TOKEN\" ) The above code will create a guild-specific slash command. Global Slash Commands can take up to an hour to register. Tip Use ctx.respond instead of ctx.send for Slash Commands. ctx.respond has all parameters of ctx.send , and avoids \" Interaction Failed\". Options \u00b6 You might want to allow your users to be able to choose options. Here's how you do that: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 @bot . slash_command ( name = 'member' ) async def choose_a_user ( ctx , user : Option ( discord . Member , \"Choose a member\" , required = False ), #required is True by default ): await ctx . respond ( f \"You chose { user } !\" ) @bot . slash_command ( name = 'channel' ) async def choose_a_channel ( ctx , channel : Option ( discord . abc . GuildChannel , \"Choose a channel\" ), # type, description ): await ctx . respond ( f \"You chose { channel } !\" ) @bot . slash_command ( name = 'choice' , description = 'Slash command description' , guild_ids = [ 1234567891010 , 103432234543 ]) async def choose ( ctx , choice = Option ( str , \"Choose an option!\" , choices = [ \"Choice1\" , \"Choice2\" , \"Choice3\" ]) ): await ctx . respond ( f \"You chose { choice } !\" ) Supported Option Types Name Value Note INTEGER int Any integer between -2^53 and 2^53 BOOLEAN bool USER discord.Member CHANNEL discord.abc.GuildChannel Includes all channel types + categories ROLE discord.Role MENTIONABLE discord.abc.Mentionable Includes users and roles NUMBER float Any double between -2^53 and 2^53 Command Groups \u00b6 SubCommand Groups \u00b6 The above image is an example of a SubCommand group. Slash Command names cannot have spaces, and they must all be in lowercase. The above Slash Commands do not have spaces, they are a command group. A command group is a group of Slash Commands used for the same purpose. They can be useful certain times, as shown above. Now, lets learn how to create Command Groups. 1 2 3 4 5 6 7 8 9 10 afk = bot . command_group ( name = 'afk' , description = 'AFK related commands' , guild_ids = [ ... ]) # guild_ids will make this a guild specific slash command. The whole command group can either be global, or guild-specific @afk . command ( name = 'set' ) #command instead of slash_command async def set ( ctx ): await ctx . respond ( \"You are now AFK!\" ) @afk . command ( name = 'remove' ) async def remove ( ctx ): await ctx . respond ( \"You are no longer AFK!\" ) SubCommand Groups within SubCommand Groups \u00b6 The below is an example of a SubCommand group within a SubCommand group. This is as far as SubCommand Groups go. Here's how you make one: 1 2 3 4 5 6 7 settings = bot . command_group ( name = \"settings\" , description = \"Change Server Settings\" , guild_ids = [ 100000000000000000 ]) prefix = settings . command_group ( name = \"prefix\" , description = \"Change the server prefix\" ) @prefix . command () async def set ( ctx ): await ctx . respond ( \"Set the prefix to `!`\" ) Limitations \u00b6 Slash Commands, too, make their own limits. An app can have up to 100 top-level global commands with unique names An app can have up to an additional 100 guild commands per guild An app can have up to 25 subcommand groups on a top-level command An app can have up to 25 subcommands within a subcommand group commands can have up to 25 options options can have up to 25 choices","title":"Slash Commands"},{"location":"Guides/slash-commands/#slash-commands","text":"This page will show you how to use Slash Commands with Pycord. Important To create commands in a guild, your app must be authorized with the applications.commands scope. In order to make commands work within a guild, the guild must authorize your application with the applications.commands scope. The bot scope is not enough. Read the Docs","title":"Slash Commands"},{"location":"Guides/slash-commands/#a-simple-slash-command","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 import discord from discord.app import Option bot = discord . Bot () # Note: If you want you can use commands.Bot instead of discord.Bot # Use discord.Bot if you don't want prefixed message commands # With discord.Bot you can use @bot.command as an alias # of @bot.slash_command but this is overriden by commands.Bot @bot . slash_command ( guild_ids = [ ... ], name = 'hello' , description = 'Say Hello!' ) # create a slash command for the supplied guilds async def hello ( ctx ): \"\"\"Say hello to the bot\"\"\" # the command description can be supplied as the docstring await ctx . respond ( f \"Hello { ctx . author } !\" ) bot . run ( \"TOKEN\" ) The above code will create a guild-specific slash command. Global Slash Commands can take up to an hour to register. Tip Use ctx.respond instead of ctx.send for Slash Commands. ctx.respond has all parameters of ctx.send , and avoids \" Interaction Failed\".","title":"A simple Slash Command"},{"location":"Guides/slash-commands/#options","text":"You might want to allow your users to be able to choose options. Here's how you do that: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 @bot . slash_command ( name = 'member' ) async def choose_a_user ( ctx , user : Option ( discord . Member , \"Choose a member\" , required = False ), #required is True by default ): await ctx . respond ( f \"You chose { user } !\" ) @bot . slash_command ( name = 'channel' ) async def choose_a_channel ( ctx , channel : Option ( discord . abc . GuildChannel , \"Choose a channel\" ), # type, description ): await ctx . respond ( f \"You chose { channel } !\" ) @bot . slash_command ( name = 'choice' , description = 'Slash command description' , guild_ids = [ 1234567891010 , 103432234543 ]) async def choose ( ctx , choice = Option ( str , \"Choose an option!\" , choices = [ \"Choice1\" , \"Choice2\" , \"Choice3\" ]) ): await ctx . respond ( f \"You chose { choice } !\" ) Supported Option Types Name Value Note INTEGER int Any integer between -2^53 and 2^53 BOOLEAN bool USER discord.Member CHANNEL discord.abc.GuildChannel Includes all channel types + categories ROLE discord.Role MENTIONABLE discord.abc.Mentionable Includes users and roles NUMBER float Any double between -2^53 and 2^53","title":"Options"},{"location":"Guides/slash-commands/#command-groups","text":"","title":"Command Groups"},{"location":"Guides/slash-commands/#subcommand-groups","text":"The above image is an example of a SubCommand group. Slash Command names cannot have spaces, and they must all be in lowercase. The above Slash Commands do not have spaces, they are a command group. A command group is a group of Slash Commands used for the same purpose. They can be useful certain times, as shown above. Now, lets learn how to create Command Groups. 1 2 3 4 5 6 7 8 9 10 afk = bot . command_group ( name = 'afk' , description = 'AFK related commands' , guild_ids = [ ... ]) # guild_ids will make this a guild specific slash command. The whole command group can either be global, or guild-specific @afk . command ( name = 'set' ) #command instead of slash_command async def set ( ctx ): await ctx . respond ( \"You are now AFK!\" ) @afk . command ( name = 'remove' ) async def remove ( ctx ): await ctx . respond ( \"You are no longer AFK!\" )","title":"SubCommand Groups"},{"location":"Guides/slash-commands/#subcommand-groups-within-subcommand-groups","text":"The below is an example of a SubCommand group within a SubCommand group. This is as far as SubCommand Groups go. Here's how you make one: 1 2 3 4 5 6 7 settings = bot . command_group ( name = \"settings\" , description = \"Change Server Settings\" , guild_ids = [ 100000000000000000 ]) prefix = settings . command_group ( name = \"prefix\" , description = \"Change the server prefix\" ) @prefix . command () async def set ( ctx ): await ctx . respond ( \"Set the prefix to `!`\" )","title":"SubCommand Groups within SubCommand Groups"},{"location":"Guides/slash-commands/#limitations","text":"Slash Commands, too, make their own limits. An app can have up to 100 top-level global commands with unique names An app can have up to an additional 100 guild commands per guild An app can have up to 25 subcommand groups on a top-level command An app can have up to 25 subcommands within a subcommand group commands can have up to 25 options options can have up to 25 choices","title":"Limitations"},{"location":"Guides/threads/","text":"Threads \u00b6 Read the docs Creating Threads \u00b6 With a few lines of code, we can create threads in Py-cord. Now, here are a few things to keep in mind: All public threads need a starting message. This message will start the thread. However, private threads (server boost level 2 required) do not require a starting message. Creating thread from a message \u00b6 1 2 message = await something . send ( \"My Starting Message\" ) await message . create_thread ( name = \"thread name\" , auto_archive_duration = 60 ) You may also use other ways, say, on_message or by using buttons. Creating thread in a channel \u00b6 1 2 channel = bot . get_channel ( ... ) # define this! await channel . create_thread ( name = \"Thread Name\" , message = None , auto_archive_duration = 60 , type = None , reason = None ) A thread type could be news_thread , public_thread , private_thread . You may use it like type=discord.ChannelType.news_thread . Deleting Threads \u00b6 1 2 thread = bot . get_channel ( thread_id ) # a thread is a kind of channel too, so we use bot.get_channel await thread . delete () Editing Threads \u00b6 Parameters \u00b6 name (str) \u2013 The new name of the thread archived (bool) \u2013 Whether to archive the thread or not. locked (bool) \u2013 Whether to lock the thread or not. invitable (bool) \u2013 Whether non-moderators can add other non-moderators to this thread. Only available for private threads. auto_archive_duration (int) \u2013 The new duration in minutes before a thread is automatically archived for inactivity. Must be one of 60, 1440, 4320, or 10080. slowmode_delay (int) \u2013 Specifies the slowmode rate limit for user in this thread, in seconds. A value of 0 disables slowmode. The maximum value possible is 21600. 1 2 3 4 5 6 7 8 thread = bot . get_channel ( id ) # a thread is a kind of channel too, so we use bot.get_channel await thread . edit ( name = \"New Name\" , archived = True , locked = True , slowmode_delay = 10 , auto_archive_duration = 60 , ) Joining Threads Automatically \u00b6 If you have a Moderation Bot, you probably want your bot to join all the threads automatically. Only by doing so will you be able to Moderate Threads properly. Thankfully, there's an event for that. 1 2 3 @bot . event async def on_thread_join ( thread ): # called whenever a thread is created/joined await thread . join () More \u00b6 There are ton of things you can do with threads. Reading this guide, you must have gotten a hang of how to use these features. Now, you should head to the docs, view all the things you can do and use the features you want accordingly. Docs: https://pycord.readthedocs.io/en/master/api.html#discord.Thread Cheatsheet \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 # THREADS CHEATSHEET import discord from discord.ext import commands bot = commands . Bot ( command_prefix = \"!\" , Intents = discord . Intents . all ()) ## Creating Threads @bot . command () async def create ( ctx ): ### Creating Threads by message message = await ctx . send ( \"I started a public thread!\" ) await message . create_thread ( name = \"New Thread\" , auto_archive_duration = 60 ) ### Creating Threads by channel channel = bot . get_channel ( ... ) await channel . create_thread ( name = \"Thread Name\" , message = message , auto_archive_duration = 60 , type = None , reason = \"User told me to do so\" , ) @bot . command () async def delete ( ctx , id : int ): # will fail if you forget to make it an integer! thread = bot . get_channel ( id ) # a thread is a kind of channel too, so we use bot.get_channel await thread . delete () @bot . command () async def edit ( ctx , id : int ): # will fail if you forget to make it an integer! thread = bot . get_channel ( id ) # a thread is a kind of channel too, so we use bot.get_channel await thread . edit ( name = \"New Name\" , archived = True , locked = True , slowmode_delay = 10 , auto_archive_duration = 60 , ) @bot . event async def on_thread_join ( thread ): await thread . join () bot . run ( \"TOKEN\" ) Problem Solving \u00b6 Unknown Message \u00b6 If you get an error looking like discord.ext.commands.errors.CommandInvokeError: Command raised an exception: HTTPException: 400 Bad Request (error code: 10008): Unknown Message There could be multiple reasons, for example, The message does not exist The message already has a thread The message is in channel x, you are trying to start a thread in channel y. The message was deleted. Forbidden \u00b6 This means that your bot does not have the necessary permissions to run the command you wanted. Give it the correct permissions, then try again. int object has no attribute id \u00b6 You probably used message.id instead of message . If not, remember that message is an object. You need to get the object, not the specify the message id. You should try to learn about Object Oriented Programming. AttributeError: 'NoneType' object has no attribute x \u00b6 This probably means the bot was unable to fetch the thread. Maybe the thread doesn't exist?","title":"Threads"},{"location":"Guides/threads/#threads","text":"Read the docs","title":"Threads"},{"location":"Guides/threads/#creating-threads","text":"With a few lines of code, we can create threads in Py-cord. Now, here are a few things to keep in mind: All public threads need a starting message. This message will start the thread. However, private threads (server boost level 2 required) do not require a starting message.","title":"Creating Threads"},{"location":"Guides/threads/#creating-thread-from-a-message","text":"1 2 message = await something . send ( \"My Starting Message\" ) await message . create_thread ( name = \"thread name\" , auto_archive_duration = 60 ) You may also use other ways, say, on_message or by using buttons.","title":"Creating thread from a message"},{"location":"Guides/threads/#creating-thread-in-a-channel","text":"1 2 channel = bot . get_channel ( ... ) # define this! await channel . create_thread ( name = \"Thread Name\" , message = None , auto_archive_duration = 60 , type = None , reason = None ) A thread type could be news_thread , public_thread , private_thread . You may use it like type=discord.ChannelType.news_thread .","title":"Creating thread in a channel"},{"location":"Guides/threads/#deleting-threads","text":"1 2 thread = bot . get_channel ( thread_id ) # a thread is a kind of channel too, so we use bot.get_channel await thread . delete ()","title":"Deleting Threads"},{"location":"Guides/threads/#editing-threads","text":"","title":"Editing Threads"},{"location":"Guides/threads/#parameters","text":"name (str) \u2013 The new name of the thread archived (bool) \u2013 Whether to archive the thread or not. locked (bool) \u2013 Whether to lock the thread or not. invitable (bool) \u2013 Whether non-moderators can add other non-moderators to this thread. Only available for private threads. auto_archive_duration (int) \u2013 The new duration in minutes before a thread is automatically archived for inactivity. Must be one of 60, 1440, 4320, or 10080. slowmode_delay (int) \u2013 Specifies the slowmode rate limit for user in this thread, in seconds. A value of 0 disables slowmode. The maximum value possible is 21600. 1 2 3 4 5 6 7 8 thread = bot . get_channel ( id ) # a thread is a kind of channel too, so we use bot.get_channel await thread . edit ( name = \"New Name\" , archived = True , locked = True , slowmode_delay = 10 , auto_archive_duration = 60 , )","title":"Parameters"},{"location":"Guides/threads/#joining-threads-automatically","text":"If you have a Moderation Bot, you probably want your bot to join all the threads automatically. Only by doing so will you be able to Moderate Threads properly. Thankfully, there's an event for that. 1 2 3 @bot . event async def on_thread_join ( thread ): # called whenever a thread is created/joined await thread . join ()","title":"Joining Threads Automatically"},{"location":"Guides/threads/#more","text":"There are ton of things you can do with threads. Reading this guide, you must have gotten a hang of how to use these features. Now, you should head to the docs, view all the things you can do and use the features you want accordingly. Docs: https://pycord.readthedocs.io/en/master/api.html#discord.Thread","title":"More"},{"location":"Guides/threads/#cheatsheet","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 # THREADS CHEATSHEET import discord from discord.ext import commands bot = commands . Bot ( command_prefix = \"!\" , Intents = discord . Intents . all ()) ## Creating Threads @bot . command () async def create ( ctx ): ### Creating Threads by message message = await ctx . send ( \"I started a public thread!\" ) await message . create_thread ( name = \"New Thread\" , auto_archive_duration = 60 ) ### Creating Threads by channel channel = bot . get_channel ( ... ) await channel . create_thread ( name = \"Thread Name\" , message = message , auto_archive_duration = 60 , type = None , reason = \"User told me to do so\" , ) @bot . command () async def delete ( ctx , id : int ): # will fail if you forget to make it an integer! thread = bot . get_channel ( id ) # a thread is a kind of channel too, so we use bot.get_channel await thread . delete () @bot . command () async def edit ( ctx , id : int ): # will fail if you forget to make it an integer! thread = bot . get_channel ( id ) # a thread is a kind of channel too, so we use bot.get_channel await thread . edit ( name = \"New Name\" , archived = True , locked = True , slowmode_delay = 10 , auto_archive_duration = 60 , ) @bot . event async def on_thread_join ( thread ): await thread . join () bot . run ( \"TOKEN\" )","title":"Cheatsheet"},{"location":"Guides/threads/#problem-solving","text":"","title":"Problem Solving"},{"location":"Guides/threads/#unknown-message","text":"If you get an error looking like discord.ext.commands.errors.CommandInvokeError: Command raised an exception: HTTPException: 400 Bad Request (error code: 10008): Unknown Message There could be multiple reasons, for example, The message does not exist The message already has a thread The message is in channel x, you are trying to start a thread in channel y. The message was deleted.","title":"Unknown Message"},{"location":"Guides/threads/#forbidden","text":"This means that your bot does not have the necessary permissions to run the command you wanted. Give it the correct permissions, then try again.","title":"Forbidden"},{"location":"Guides/threads/#int-object-has-no-attribute-id","text":"You probably used message.id instead of message . If not, remember that message is an object. You need to get the object, not the specify the message id. You should try to learn about Object Oriented Programming.","title":"int object has no attribute id"},{"location":"Guides/threads/#attributeerror-nonetype-object-has-no-attribute-x","text":"This probably means the bot was unable to fetch the thread. Maybe the thread doesn't exist?","title":"AttributeError: 'NoneType' object has no attribute x"},{"location":"Guides/voice-commands/","text":"Voice Commands \u00b6 Installation \u00b6 1 2 3 4 5 # Linux/macOS python3 -m pip install -U \"py-cord[voice]\" # Windows py -3 -m pip install -U py-cord [ voice ] Joining a voice channel \u00b6 1 2 3 4 5 6 7 8 9 10 11 @bot . command () async def join ( ctx ): voice = ctx . message . author . voice if voice != None : await voice . channel . connect () await ctx . send ( f \"Connected and bound to { voice . channel . mention } !\" ) else : await ctx . send ( \"You need to be connected to a voice channel to use this command!\" ) Leaving a voice channel \u00b6 1 2 3 4 5 6 7 8 @bot . command () async def leave ( ctx ): voice = ctx . voice_client if voice != None : await voice . disconnect () await ctx . send ( f \"Left the VC!\" ) else : await ctx . send ( \"I am not connected to any voice channel!\" ) Playing Audio \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 @bot . command ( name = \"play\" ) async def play ( ctx ): voice_channel = ctx . author . voice . channel if voice_channel != None : vc = await voice_channel . connect () vc . play ( discord . FFmpegPCMAudio ( executable = r \"C:\\Path\\ffmpeg.exe\" , source = r \"C:\\Users\\HP\\Downloads\\never_gonna_give_you_up.mp3\" , ) ) await ctx . send ( f \"Connected to { voice_channel . name } , playing audio.\" ) else : await ctx . send ( \"You need to be in a voice channel to use this command\" ) This is how you play local audio files. Remember to replace Path and source with your own values. Eg. C:\\KMPlayer\\ffmprg.exe for me. You can find the path through searching in file explorer on windows. There are several things you can do, these are just the basics. For more commands like stop, resume, pause you will need to read the docs. Its pretty simple and easy to figure out.","title":"Voice Commands"},{"location":"Guides/voice-commands/#voice-commands","text":"","title":"Voice Commands"},{"location":"Guides/voice-commands/#installation","text":"1 2 3 4 5 # Linux/macOS python3 -m pip install -U \"py-cord[voice]\" # Windows py -3 -m pip install -U py-cord [ voice ]","title":"Installation"},{"location":"Guides/voice-commands/#joining-a-voice-channel","text":"1 2 3 4 5 6 7 8 9 10 11 @bot . command () async def join ( ctx ): voice = ctx . message . author . voice if voice != None : await voice . channel . connect () await ctx . send ( f \"Connected and bound to { voice . channel . mention } !\" ) else : await ctx . send ( \"You need to be connected to a voice channel to use this command!\" )","title":"Joining a voice channel"},{"location":"Guides/voice-commands/#leaving-a-voice-channel","text":"1 2 3 4 5 6 7 8 @bot . command () async def leave ( ctx ): voice = ctx . voice_client if voice != None : await voice . disconnect () await ctx . send ( f \"Left the VC!\" ) else : await ctx . send ( \"I am not connected to any voice channel!\" )","title":"Leaving a voice channel"},{"location":"Guides/voice-commands/#playing-audio","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 @bot . command ( name = \"play\" ) async def play ( ctx ): voice_channel = ctx . author . voice . channel if voice_channel != None : vc = await voice_channel . connect () vc . play ( discord . FFmpegPCMAudio ( executable = r \"C:\\Path\\ffmpeg.exe\" , source = r \"C:\\Users\\HP\\Downloads\\never_gonna_give_you_up.mp3\" , ) ) await ctx . send ( f \"Connected to { voice_channel . name } , playing audio.\" ) else : await ctx . send ( \"You need to be in a voice channel to use this command\" ) This is how you play local audio files. Remember to replace Path and source with your own values. Eg. C:\\KMPlayer\\ffmprg.exe for me. You can find the path through searching in file explorer on windows. There are several things you can do, these are just the basics. For more commands like stop, resume, pause you will need to read the docs. Its pretty simple and easy to figure out.","title":"Playing Audio"},{"location":"More/git/","text":"Git \u00b6 Git is software for tracking changes in any set of files, usually used for coordinating work among programmers collaboratively developing source code during software development. Its goals include speed, data integrity, and support for distributed, non-linear workflows (thousands of parallel branches running on different systems). Windows \u00b6 Visit https://gitforwindows.org/ or https://git-scm.com/download/windows Linux \u00b6 Visit https://git-scm.com/download/linux (it's extremely likely in your distros repository) Mac \u00b6 Visit https://git-scm.com/download/mac (it's in brew) Others \u00b6 Choco Package Manager \u00b6 If you use choco package manager, use: choco install git Scoop \u00b6 If you use scoop, use: scoop install git","title":"Installing Git"},{"location":"More/git/#git","text":"Git is software for tracking changes in any set of files, usually used for coordinating work among programmers collaboratively developing source code during software development. Its goals include speed, data integrity, and support for distributed, non-linear workflows (thousands of parallel branches running on different systems).","title":" Git"},{"location":"More/git/#windows","text":"Visit https://gitforwindows.org/ or https://git-scm.com/download/windows","title":" Windows"},{"location":"More/git/#linux","text":"Visit https://git-scm.com/download/linux (it's extremely likely in your distros repository)","title":" Linux"},{"location":"More/git/#mac","text":"Visit https://git-scm.com/download/mac (it's in brew)","title":" Mac"},{"location":"More/git/#others","text":"","title":"Others"},{"location":"More/git/#choco-package-manager","text":"If you use choco package manager, use: choco install git","title":"Choco Package Manager"},{"location":"More/git/#scoop","text":"If you use scoop, use: scoop install git","title":"Scoop"}]}